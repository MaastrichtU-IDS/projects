"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbstractFilterHash = void 0;
const crypto_1 = require("crypto");
const bus_query_operation_1 = require("@comunica/bus-query-operation");
const rdf_string_1 = require("rdf-string");
/**
 * A comunica Hash Query Operation Actor.
 */
class AbstractFilterHash extends bus_query_operation_1.ActorQueryOperationTypedMediated {
    constructor(args, operator) {
        super(args, operator);
        if (!AbstractFilterHash.doesHashAlgorithmExist(this.hashAlgorithm)) {
            throw new Error(`The given hash algorithm is not present in this version of Node: ${this.hashAlgorithm}`);
        }
        if (!AbstractFilterHash.doesDigestAlgorithmExist(this.digestAlgorithm)) {
            throw new Error(`The given digest algorithm is not present in this version of Node: ${this.digestAlgorithm}`);
        }
    }
    /**
       * Check if the given hash algorithm (such as sha1) exists.
       * @param {string} hashAlgorithm A hash algorithm.
       * @return {boolean} If it exists.
       */
    static doesHashAlgorithmExist(hashAlgorithm) {
        return crypto_1.getHashes().includes(hashAlgorithm);
    }
    /**
       * Check if the given digest (such as base64) algorithm exists.
       * @param {string} digestAlgorithm A digest algorithm.
       * @return {boolean} If it exists.
       */
    static doesDigestAlgorithmExist(digestAlgorithm) {
        return ['latin1', 'hex', 'base64'].includes(digestAlgorithm);
    }
    /**
       * Create a string-based hash of the given object.
       * @param {string} hashAlgorithm A hash algorithm.
       * @param {string} digestAlgorithm A digest algorithm.
       * @param bindings The bindings to hash.
       * @return {string} The object's hash.
       */
    static hash(hashAlgorithm, digestAlgorithm, bindings) {
        const hash = crypto_1.createHash(hashAlgorithm);
        hash.update(require('canonicalize')(bindings.map(x => rdf_string_1.termToString(x))));
        return hash.digest(digestAlgorithm);
    }
}
exports.AbstractFilterHash = AbstractFilterHash;
//# sourceMappingURL=AbstractFilterHash.js.map